@media screen {
	/* Define the padding that's applied around the slides */
	:root {
		/* Slides */
		--gutter-vertical: 0.25rem;
		--gutter-horizontal: 1rem;

		/* The following are provided by script...
		 *
		 * --computed-slide-height
		 * --computed-slide-width
		 * --computed-vertical-margin
		 * --computed-horizontal-margin
		 * --computed-base-font-size */

		/* UI */
		--floaty-thing-room: 0.25em;
		--fade-length: 1s;
	}

	/* This just makes everything make sense */
	* { box-sizing: border-box; }

	/*
	 *
	 * Slide content
	 *
	 */

	/* Scale the root em size as requested by the user */
	html {
		font-size: var(--computed-base-font-size);
		margin: 0;
		padding: 0;
	}

	body {
		margin: 0;
		padding: 0;
	}

	/* Non-current slides shouldn't be shown */
	.slide { display: none; }

	/* The current slide should be as large as it can be to fit within the
	 * screen. The author-desired aspect ratio of the slides is a CSS variable.
	 * The script works out the dimensions of the slides in pixels and stores
	 * them in other CSS variables.
	 *
	 * The base font size is specified by the author as a percentage of the
	 * slide height, so that things are nicely scaleable. Again, the script
	 * works out what this font size is in pixels.
	 *
	 * The script sets the slide's layout to flex. This allows the entire
	 * slide's contents to expand to fill the slide, which allows effects such
	 * as positioning content vertically at the bottom of the slide (or the
	 * middle).
	 *
	 * It's assumed that most slides will be simple text/lists/images and will
	 * want some padding (as defined above) by default. */
	.slide.active {
		position: fixed;
		width: var(--computed-slide-width);
		height: var(--computed-slide-height);
		max-width: var(--computed-slide-width);
		max-height: var(--computed-slide-height);
		margin-top: var(--computed-vertical-margin);
		margin-bottom: var(--computed-vertical-margin);
		margin-left: var(--computed-horizontal-margin);
		margin-right: var(--computed-horizontal-margin);
		padding: var(--gutter-vertical) var(--gutter-horizontal);
		display: flex;
		flex-direction: column;
	}

	/* Support vertical splitting of content within part of a slide.
	 *
	 * TODO: unused currently - but could be useful? */
	.slide.active [data-split] {  /* doesn't match slide but that's above */
		display: flex;
		flex-direction: column;
	}

	/* TODO: don't think horizontal styles are working or being used ATM
	 *
	 * FIXME: horizontal + bottom on the slide doesn't work */
	.slide.horizontal { flex-direction: row; }

	/* Slides that have the class of (top|middle|bottom) or elements within
	 * slides that have one of those classes should align their content
	 * vertically accordingly. To do this, they are rendred as flexboxes (the
	 * slides themselves already are). */
	.slide.active.top:not(.horizontal),
	.slide.active .top {
		display: flex;
		flex-direction: column;
		justify-content: flex-start;
		height: 100%;
		width: 100%;
	}

	.slide.active.bottom:not(.horizontal),
	.slide.active .bottom {
		display: flex;
		flex-direction: column;
		justify-content: flex-end;
		height: 100%;
		width: 100%;
	}

	.slide.active.middle:not(.horizontal),
	.slide.active .middle {
		display: flex;
		flex-direction: column;
		justify-content: center;
		height: 100%;
		width: 100%;
	}

	/* Slides can be split into different vertical (or TODO horizontal) parts.
	 * The author can specify the allocation of space to each of these parts,
	 * but if they don't we need a sensible default. By making each part
	 * equally greedy for the whole space, we arrive at each part being
	 * allocated (1/n)th of the space. */
	[data-split] > * { flex-basis: 100%; }

	/* Some slides will want to take up the full space, with no padding. This
	 * can be used to achieve some effects, such as full-height/-width
	 * backgrounds. */
	.slide.active.full { padding: 0; }

	/* If a slide asked to use the full-size layout /only/ so that it could
	 * have full-height/-width background colours - and actually /does/ want
	 * the normal padding around its text content - then the class "padded" can
	 * be added to insert the padding back in inside each top-level slide
	 * content child element. */
	.slide.active.full.padded:not(.horizontal) > :first-child {
		padding-top: var(--gutter-vertical);
		padding-left: var(--gutter-horizontal);
		padding-right: var(--gutter-horizontal);
	}

	.slide.active.full.padded.horizontal > :first-child {
		padding-top: var(--gutter-vertical);
		padding-left: var(--gutter-horizontal);
		padding-bottom: var(--gutter-vertical);
	}

	.slide.active.full.padded > * {
		padding-left: var(--gutter-horizontal);
		padding-right: var(--gutter-horizontal);
	}

	.slide.active.full.padded:not(.horizontal) > :last-child {
		padding-left: var(--gutter-horizontal);
		padding-right: var(--gutter-horizontal);
		padding-bottom: var(--gutter-vertical);
	}

	.slide.active.full.padded.horizontal > :last-child {
		padding-top: var(--gutter-vertical);
		padding-right: var(--gutter-horizontal);
		padding-bottom: var(--gutter-vertical);
	}

	/* If the "centre" (or "center") class was added to a slide, the user wants
	 * the text centred horizontally. This needs to be passed on to the
	 * script-created <div>. */
	.slide.active.centre,
	.slide.active.center { text-align: center; }

	.slide.active .centre,
	.slide.active .center { text-align: center; }

	/* Likewise if the user wanted right-aligned content. */
	.slide.active.right { text-align: right; }

	.slide.active .right { text-align: right; }

	/* By default, assume that images want to be as big as they can be to fill
	 * the slide. */
	img {
		display: block;
		width: 100%;
		height: 100%;
		object-fit: contain;
	}

	/* ...and similar for figures. */
	figure {
		margin: 0;
		max-width: 100%;
		max-height: 100%;
	}

	/* TODO: combine figure and iframe? */

	/* ...and iframes. */
	iframe {
		margin: 0;
		width: 100%;
		height: 100%;
	}

	/* The author can specify that certain items on a slide are to be revealed
	 * gradually (by setting the 'data-pause' attribute on the container of the
	 * things). A custom attribute is used to track the state of things not yet
	 * revealed (it's added automatically when the slideshow starts). */
	[data-storyslides-step] {
		visibility: hidden;
	}

	/* Story mode content should not be available to anyone when we are in
	 * slides mode, which we are if this stylesheet is loaded.
	 *
	 * This includes the help text on the story mode top bar. */
	.story { display: none; }

	/*
	 *
	 * UI
	 *
	 */

	/* The progress bar is a container with nested <div> that adjusts its
	 * width. Got this neat trick from impress.js; thanks :-).
	 *
	 * Note: no colour is specified here, so it won't actually show up. The
	 *       theme stylesheet needs to specify a background-color for the
	 *       #storyslides-progress>div element. */
	#storyslides-progress {
		display: block;
		position: fixed;
		right: 0;
		left: 0;
		bottom: 0;
	}
	#storyslides-progress > div { width: 0; }

	/* The mode-switch, previous and next buttons come first in the DOM and
	 * focus order, but must be rendered on top of the slides. Decided to do
	 * this rather than put them all after the slides, in case someone ever
	 * puts a focusable element on a slide. */
	.storyslides-ui button,
	#storyslides-mode-story-explainer { z-index: 1; }

	/* On mobile and desktop, the buttons in the "menu" (which includes the
	 * slides/story mode toggle) must be above the previous and next buttons */
	#storyslides-mobile-menu-content { z-index: 2; }
	#storyslides-mobile-menu-content button { z-index: 2; } /* TODO: why needed? */

	/* TODO this isn't mobile-first but treats mobile and desktop equally - don't want default styles for the mobile menu in desktop */
	@media (hover: none) and (pointer: coarse) {
		/* FIXME doc */
		#storyslides-mobile-menu-toggle {
			position: fixed;
			top: 0;
			left: 0;
			z-index: 2;  /* ? TODO dry variable? */
			margin: 0.25rem;
		}

		/* FIXME DRY */
		#storyslides-mobile-menu-toggle[aria-expanded="true"] {
			position: fixed;
			top: 0;
			left: 0;
			z-index: 2;  /* ? TODO Needed??? dry variable? */
			background-color: white;
			color: black;
			border-color: black;
		}

		/* FIXME doc */

		/* FIXME change appearnce of button when expanded */
		#storyslides-mobile-menu-content {
			position: fixed;
			top: 0;
			left: 3.7rem;
			right: 0;
			bottom: 0;
			overflow-y: scroll;

			/* FIXME DRY with dialog? */
			background-color: black;
			border: 0.25em solid black;
			outline: 0.1em solid white;
		}

		#storyslides-mobile-menu-content button { margin-bottom: 0.25rem; }
	}

	/* FIXME doc and combine with later counterpart one? */
	.storyslides-ui .mobile-none { display: none; }

	/* Previous slide and next slide invisible buttons are used to move between
	 * slides on mobile devices - this avoided the need for custom gesture
	 * detection (e.g. swipe between slides), which would've blocked
	 * pinch-to-zoom gestures. */
	#storyslides-button-previous,
	#storyslides-button-next {
		background: none;
		position: fixed;
		top: 0;
		bottom: 0;
		width: 33vw;
		border: none;
	}
	#storyslides-button-previous { left: 0; }
	#storyslides-button-next { right: 0; }

	/* When the previous/next buttons get focus, show large back/forward arrows
	 * within them, to indicate their purpose. Drop-shadows are used to improve
	 * contrast. */
	#storyslides-button-previous > span,
	#storyslides-button-next > span {
		display: none;
	}

	#storyslides-button-previous:focus > span,
	#storyslides-button-next:focus > span {
		display: inline;
		color: white;
		font-size: 30vw;
		visibility: visible;
		filter: drop-shadow(0 0 0.05em black);
	}

	/* Many elements (including buttons and the help info) get a nice border
	 * effect. The border style is tweaked below, depending on the type of
	 * element, to help people distinguish between actionable and informative
	 * stuff. */
	.storyslides-ui button,
	.storyslides-dialog button,
	#storyslides-button-mode-toggle:focus,
	.storyslides-nice-border {
		padding: 0.25em;
		border: 0.1em solid white;
		border-radius: 0.5em;
		background-color: black;
		color: white;
	}

	/* On desktop we can have wider borders */
	@media (hover: hover) and (pointer: fine) {
		.storyslides-ui button,
		.storyslides-dialog button,
		#storyslides-button-mode-toggle:focus,
		.storyslides-nice-border {
			padding: 0.5em;
			border: 0.1em solid white;
			border-radius: 0.5em;
			background-color: black;
			color: white;
		}
	}

	/* Override native button styling */
	.storyslides-ui button,
	.storyslides-dialog button { font-size: inherit; }

	/* Help info gets the same effect but a less prominent border, so it looks
	 * less actionable. */
	p.storyslides-nice-border { border-style: dashed; }

	/* FIXME doc */

	/* FIXME move bits above? */

	/* A button is added at the top of the page to move to story mode. This is
	 * the same as pressing the 's' key, but is more easily discoverable by
	 * screen-reader and mobile users.
	 *
	 * This story mode button should only be shown when focused on desktop, but
	 * should be visible for all on mobile. The way we classify devices is
	 * based on their primary pointer device characteristics.
	 *
	 * A button to switch into full-screen mode on mobile is also provided.
	 * This is not needed at all on desktop. (We have the mode-switch button on
	 * desktop only so that screen-reader users have more chance of discovering
	 * story mode.)
	 *
	 * On iOS Safari, it's not possible to get rid of the browser UI bars that
	 * sit on top of the page, because in slides mode it's not possible to
	 * scroll the page, so the buttons need to be twoards the middles. */
	@media (hover: hover) and (pointer: fine) {
		#storyslides-button-mode-toggle {
			position: fixed;
			clip: rect(1px, 1px, 1px, 1px);
			padding: 0;
			border: 0;
			height: 1px;
			width: 1px;
			overflow: hidden;
			white-space: nowrap;
		}

		#storyslides-button-mode-toggle:focus {
			/* Requiredeties */
			height: auto;
			width: auto;
			clip: auto;

			/* Niceties */
			margin: var(--floaty-thing-room);
		}

		/* We don't need the fullscreen or help buttons on desktop. Some
		 * content is added to the help dialogs for mobile users */
		.storyslides-ui .mobile-only,
		.storyslides-dialog .mobile-only,
		#storyslides-mode-story-explainer { display: none; }

		/* The mobile menu is hidden by default, but shouldn't be on desktop,
		 * as there we are only showing the mode toggle (when focused) */
		.storyslides-ui .mobile-none { display: block; }

		/* TODO do ^ where declared */
	}

	/* Show the description when it's helpful */

	/* FIXME do a similar container thing for mobile? */
	#storyslides-button-mode-toggle:focus ~ #storyslides-mode-story-explainer {
		/* Nullify the hiding */
		display: block;

		/* Style the para... */
		position: fixed;
		bottom: 0;
		left: 0;
		right: 0;
		height: 40vh;
		overflow-y: scroll;
		margin: var(--floaty-thing-room);
	}

	/* Roll our own dialogs as <dialog> support isn't great.
	 *
	 * On mobile devices, we make them bigger, and use the technique
	 * described in the CSS-Tricks article:
	 * https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */
	.storyslides-dialog {
		position: fixed;
		top: 0;
		right: 0;
		left: 0;
		bottom: 0;
		height: 100%;
		width: 100%;
		overflow-y: scroll;
		margin: auto;
		padding: 1em;
		font-size: large;
		background-color: black;
		border: 0.25em solid white;
		outline: 0.1em solid black;
	}

	@media (min-width: 42em) {
		.storyslides-dialog {
			height: auto;  /* FIXME doesn't do minimum */
			width: auto;   /* '' */
			max-height: 75%;
			max-width: 85%;
		}
	}

	/* Desktop devices... */
	@media (hover: hover) and (pointer: fine) {
		.storyslides-dialog {
			height: auto;  /* FIXME */
			width: auto;   /* '' */
			max-width: 75vw;
			max-height: 85vh;
		}
	}

	/* The intro has less text on it */
	#storyslides-dialog-intro { font-size: x-large; }

	.storyslides-dialog button.close {
		float: right;
		margin-top: 0.5em;
		margin-bottom: 1em;
	}

	/* FIXME doesn't match up with focus of buttons above */
	.storyslides-dialog button.close:focus {
		background-color: white;
		color: black;
	}

	.storyslides-dialog table {
		margin-top: 1em;
		margin-bottom: 1em;
	}

	.storyslides-dialog tr:not(:first-child),
	hr { border-bottom: 0.1em solid white; }

	.storyslides-dialog td:first-child { text-align: center; }

	/* Only set custom styles for <kbd> in our own UI */
	.storyslides-ui kbd,
	.storyslides-dialog kbd {
		/* Looks like, but also not exactly like, buttons */
		display: inline-block;
		border: 0.1em dotted white;
		border-radius: 0.25em;
		padding-left: 0.25em;
		padding-right: 0.25em;
	}

	/* As the <dialog> element and it's ::backdrop aren't maturely supported
	 * yet, we roll our own, with a nice smooth animation. */
	#storyslides-main-content[aria-hidden="true"] {
		opacity: 0.5;
		transition: opacity 0.5s;
	}
	#storyslides-main-content { transition: opacity 0.5s; }

	/* Give both the help info and lock indicator some spacing */
	#storyslides-help-info,
	#storyslides-lock-indicator {
		position: fixed;
		margin: var(--floaty-thing-room);
		right: 0;
		opacity: 0;
	}

	/* ...but position them at different heights */
	#storyslides-help-info {
		top: 0;
		background-color: unset;
	}
	#storyslides-lock-indicator { bottom: 0; }

	/* The help prompt is shown only when we're on the first slide, after a
	 * while (thanks to impress.js for this technique :-). Likewise, the lock
	 * indicator is only shown when the slide is locked. */
	.first-slide #storyslides-help-info,
	.storyslides-slide-locked #storyslides-lock-indicator {
		opacity: 1;
		transition: opacity var(--fade-length) 3s;
	}
	.storyslides-slide-locked #storyslides-lock-indicator { transition: opacity var(--fade-length); }

	/* When the slide is locked, disable UI bits */
	.storyslides-slide-locked .storyslides-ui,
	.storyslides-slide-locked .storyslides-dialog { display: none; }

	/* FIXME causes the text to disappear too soon */
	#storyslides-lock-indicator > span { display: none; }
	.storyslides-slide-locked #storyslides-lock-indicator > span { display: block; }

	/* On mobile, don't display the hep info banner */
	@media (hover: none) and (pointer: coarse) {
		#storyslides-help-info { display: none; }
	}
}
